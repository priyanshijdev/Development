🔹 async/await & Promises (Non-blocking I/O)
✅ Used for asynchronous tasks that don't block the JavaScript thread.
✅ Works best for network requests (APIs), database queries, file reads, etc.
✅ Does NOT create a new thread, everything still runs on the main thread

example:
async function fetchData() {
  console.log("Fetching data...");
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  const data = await response.json();
  console.log("Data received:", data);
}

fetchData();
console.log("This runs while data is being fetched!"); 

✅ Here, async/await prevents blocking while waiting for the network request to complete.
❌ BUT, if you run a CPU-intensive task (like factorial computation), it will still block the UI!

---------------------------------------------------------------------------------------------------------------------

🔹 Web Workers (True Multi-threading for Heavy Tasks)
✅ Used for CPU-intensive tasks (e.g., large calculations, image processing).
✅ Runs in a separate thread, so it doesn’t block the UI.
✅ Communication happens via postMessage() (no shared memory).

Example: Heavy Calculation with Web Worker

self.onmessage = function (event) {
  let num = event.data;
  let result = 1;
  for (let i = 1; i <= num; i++) {
    result *= i;
  }
  self.postMessage(result);
};



Key Differences
Feature	  Async/Await & Promises	      Web Workers
Threading	  Single-threaded	              Multi-threaded
Use Case	  Network calls, DB queries	     Heavy calculations, CPU-intensive tasks
Blocking?	  No blocking,runs on main thread  	  Runs in a separate thread (no UI lag)
Best for	    Fetch API, setTimeout, file I/O	  Data processing, image manipulation, cryptography
Can access DOM?      	Yes	❌                           No


 When to Use What?
Use async/await for:
✅ Fetching data from APIs
✅ Reading/writing files asynchronously
✅ Database queries

Use Web Workers for:
✅ Heavy number crunching (e.g., factorials, complex loops)
✅ Image processing
✅ Real-time analytics
